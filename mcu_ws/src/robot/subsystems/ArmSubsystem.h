/**
 * @file ArmSubsystem.h
 * @date 12/21/2025
 * @author Generated by Copilot
 * @brief Pseudo-code Arm Subsystem for moving the robot arm via service
 * interface.
 */

#ifndef ARMSUBSYSTEM_H
#define ARMSUBSYSTEM_H

#include <BaseSubsystem.h>
#include <mcu_msgs/msg/arm_susbsytem.h>
#include "DebugLog.h"
#include <mcu_msgs/srv/arm_control.h>
#include <microros_manager_robot.h>

#include "PCA9685Driver.h"
#include "robot/drive-base/EncoderDriver.h"

#ifdef USE_TEENSYTHREADS
#include <TeensyThreads.h>
#endif

namespace Subsystem {

// Setup carries references to hardware drivers the arm uses
class ArmSubsystemSetup : public Classes::BaseSetup {
 public:
  ArmSubsystemSetup(const char* _id, Robot::PCA9685Driver* servo_driver,
                    Drivers::EncoderDriver* encoder_driver,
                    uint32_t movement_duration_ms = 2000)
      : Classes::BaseSetup(_id),
        servo_(servo_driver),
        encoder_(encoder_driver),
        movement_duration_ms_(movement_duration_ms) {}

  Robot::PCA9685Driver* servo_ = nullptr;
  Drivers::EncoderDriver* encoder_ = nullptr;
  uint32_t movement_duration_ms_ = 2000;  // Time to complete movement
};

// Pseudo-code subsystem: publishes current `ArmSusbsytem` state and
// accepts commands via a service to change states.
class ArmSubsystem : public IMicroRosParticipant,
                     public Classes::BaseSubsystem {
 public:
  explicit ArmSubsystem(const ArmSubsystemSetup& setup)
      : Classes::BaseSubsystem(setup), setup_(setup) {}

  // Lifecycle hooks
  bool init() override {
    state_ = mcu_msgs__msg__ArmSusbsytem__INIT;
    DEBUG_PRINTLN("[ARM] init OK (pseudo-code subsystem)");
    return true;
  }
  void begin() override {
    state_ = mcu_msgs__msg__ArmSusbsytem__ARMED;
    DEBUG_PRINTLN("[ARM] begin -> ARMED");
  }
  void update() override {
    // Pseudo-code: read encoder and publish current arm status periodically
    // float pos = (setup_.encoder_) ? setup_.encoder_->getPosition().position :
    // 0.0f; translate `pos` into feedback for state machine

    // Handle non-blocking state transitions
    updateMovementState();

    publishState();
  }
  void pause() override { state_ = mcu_msgs__msg__ArmSusbsytem__STOPPED; }
  void reset() override {
    state_ = mcu_msgs__msg__ArmSusbsytem__PRE_INIT;
    position_state_ = mcu_msgs__msg__ArmSusbsytem__POSITION_RETRACTED;
    intake_state_ = mcu_msgs__msg__ArmSusbsytem__INTAKE_OFF;
    item_state_ = mcu_msgs__msg__ArmSusbsytem__ITEM_NONE;
    movement_start_time_ = 0;
  }
  const char* getInfo() override { return "ArmSubsystem"; }

  // micro-ROS wiring
  bool onCreate(rcl_node_t* node, rclc_executor_t* executor) override {
    node_ = node;
    DEBUG_PRINTLN("[ARM] onCreate OK (stub)");
    // Pseudo-code: create publisher for `mcu_msgs/ArmSusbsytem`
    // rclc_publisher_init_default(&pub_state_, node_,
    //     ROSIDL_GET_MSG_TYPE_SUPPORT(mcu_msgs, msg, ArmSusbsytem),
    //     "arm/state");

    // Pseudo-code: create service for `mcu_msgs/srv/ArmControl`
    // rclc_service_init_default(&srv_control_, node_,
    //     ROSIDL_GET_SRV_TYPE_SUPPORT(mcu_msgs, srv, ArmControl),
    //     "arm/control");
    // rclc_executor_add_service(executor, &srv_control_, &srv_req_, &srv_res_,
    //     &ArmSubsystem::onServiceStatic, ON_NEW_REQUEST);

    return true;
  }
  void onDestroy() override {
    // Pseudo-code: clean up micro-ROS entities if needed
    // rcl_publisher_fini(&pub_state_, node_);
    // rcl_service_fini(&srv_control_, node_);
    node_ = nullptr;
  }

  // Pseudo-code: publish current arm status
  void publishState() {
    // Fill out `msg_` from internal state variables
    msg_.state = state_;
    msg_.position_state = position_state_;
    msg_.intake_state = intake_state_;
    msg_.item_state = item_state_;

    // Pseudo-code publish
    // rcl_publish(&pub_state_, &msg_, NULL);
  }

  // Service handler to control arm movement
  void handleServiceControl(const mcu_msgs__srv__ArmControl_Request* request,
                            mcu_msgs__srv__ArmControl_Response* response) {
    // Validate request - only accept commands when armed or running
    if (state_ != mcu_msgs__msg__ArmSusbsytem__ARMED &&
        state_ != mcu_msgs__msg__ArmSusbsytem__RUNNING) {
      response->accepted = false;
      // response->message =
      // rosidl_runtime_c__String__assign(&response->message, "Arm not ready");
      return;
    }

    // Set intake state
    intake_state_ = request->intake_command;
    // Pseudo-code: control intake motor/servo based on intake_state_
    // if (intake_state_ == mcu_msgs__msg__ArmSusbsytem__INTAKE_ON) {
    //   setup_.servo_->bufferPWM(INTAKE_CHANNEL, INTAKE_ON_PWM);
    // } else {
    //   setup_.servo_->bufferPWM(INTAKE_CHANNEL, INTAKE_OFF_PWM);
    // }

    // Handle position command
    target_position_state_ = request->target_position_state;

    if (target_position_state_ ==
        mcu_msgs__srv__ArmControl_Request__POSITION_CUSTOM) {
      target_custom_position_ = request->custom_position;
    }

    // Start movement sequence
    state_ = mcu_msgs__msg__ArmSusbsytem__RUNNING;
    position_state_ = mcu_msgs__msg__ArmSusbsytem__POSITION_MOVING;
    movement_start_time_ = millis();
    movement_speed_ = request->speed;

    // Pseudo-code: command servo to target position
    // int16_t target_pos = getTargetPosition(target_position_state_,
    // target_custom_position_); uint16_t pwm_value = positionToPWM(target_pos);
    // setup_.servo_->bufferPWM(ARM_JOINT_CHANNEL, pwm_value);

    response->accepted = true;
    // rosidl_runtime_c__String__assign(&response->message, "Command accepted");
  }

#ifdef USE_TEENSYTHREADS
  void beginThreaded(uint32_t stackSize, int /*priority*/ = 1,
                     uint32_t updateRateMs = 20) {
    task_delay_ms_ = updateRateMs;
    threads.addThread(taskFunction, this, stackSize);
  }

 private:
  static void taskFunction(void* pvParams) {
    auto* self = static_cast<ArmSubsystem*>(pvParams);
    self->begin();
    while (true) {
      self->update();
      threads.delay(self->task_delay_ms_);
    }
  }
  uint32_t task_delay_ms_ = 20;
#endif

 private:
  // Non-blocking state transition handler
  void updateMovementState() {
    if (position_state_ == mcu_msgs__msg__ArmSusbsytem__POSITION_MOVING) {
      uint32_t elapsed = millis() - movement_start_time_;

      // Simple time-based movement completion (non-blocking delay)
      if (elapsed >= setup_.movement_duration_ms_) {
        // Movement complete, update to target state
        position_state_ = target_position_state_;
      }
    }
  }

  const ArmSubsystemSetup setup_;

  // micro-ROS entities
  rcl_node_t* node_ = nullptr;
  rcl_publisher_t pub_state_{};
  rcl_service_t srv_control_{};

  // Messages (storage reused by executor)
  mcu_msgs__msg__ArmSusbsytem msg_{};
  mcu_msgs__srv__ArmControl_Request srv_req_{};
  mcu_msgs__srv__ArmControl_Response srv_res_{};

  // Internal arm states (mirror of `ArmSusbsytem.msg` constants)
  uint8_t state_ = mcu_msgs__msg__ArmSusbsytem__PRE_INIT;
  uint8_t position_state_ = mcu_msgs__msg__ArmSusbsytem__POSITION_RETRACTED;
  uint8_t intake_state_ = mcu_msgs__msg__ArmSusbsytem__INTAKE_OFF;
  uint8_t item_state_ = mcu_msgs__msg__ArmSusbsytem__ITEM_NONE;

  // Movement tracking for non-blocking delays
  uint8_t target_position_state_ =
      mcu_msgs__msg__ArmSusbsytem__POSITION_RETRACTED;
  int16_t target_custom_position_ = 0;
  uint8_t movement_speed_ = 128;
  uint32_t movement_start_time_ = 0;
};

}  // namespace Subsystem

#endif

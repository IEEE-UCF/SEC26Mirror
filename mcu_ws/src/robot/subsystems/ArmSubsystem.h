/**
 * @file ArmSubsystem.h
 * @date 12/21/2025
 * @author Generated by Copilot
 * @brief Pseudo-code Arm Subsystem for moving the robot arm via service
 * interface.
 */

#ifndef ARMSUBSYSTEM_H
#define ARMSUBSYSTEM_H

#include <BaseSubsystem.h>
#include <mcu_msgs/msg/arm_susbsytem.h>
#include <mcu_msgs/srv/arm_control.h>
#include <microros_manager_robot.h>

#include "PCA9685Driver.h"
#include "TimedSubsystem.h"
#include "robot/drive-base/EncoderDriver.h"

namespace Subsystem {

// Setup carries references to hardware drivers the arm uses
class ArmSubsystemSetup : public Classes::BaseSetup {
 public:
  ArmSubsystemSetup(const char* _id, Robot::PCA9685Driver* servo_driver,
                    Drivers::EncoderDriver* encoder_driver,
                    uint32_t movement_duration_ms = 2000)
      : Classes::BaseSetup(_id),
        servo_(servo_driver),
        encoder_(encoder_driver),
        movement_duration_ms_(movement_duration_ms) {}

  Robot::PCA9685Driver* servo_ = nullptr;
  Drivers::EncoderDriver* encoder_ = nullptr;
  uint32_t movement_duration_ms_ = 2000;  // Time to complete movement
};

// Pseudo-code subsystem: publishes current `ArmSusbsytem` state and
// accepts commands via a service to change states.
class ArmSubsystem : public IMicroRosParticipant,
                     public Subsystem::TimedSubsystem {
 public:
  explicit ArmSubsystem(const ArmSubsystemSetup& setup)
      : Subsystem::TimedSubsystem(setup), setup_(setup) {}

  // Lifecycle hooks
  bool init() override {
    state_ = mcu_msgs__msg__ArmSusbsytem__INIT;
    return true;
  }
  void begin() override { state_ = mcu_msgs__msg__ArmSusbsytem__ARMED; }
  void update() override {
    // Pseudo-code: read encoder and publish current arm status periodically
    // float pos = (setup_.encoder_) ? setup_.encoder_->getPosition().position :
    // 0.0f; translate `pos` into feedback for state machine

    // Handle non-blocking state transitions
    updateMovementState();

    publishState();
  }
  void pause() override { state_ = mcu_msgs__msg__ArmSusbsytem__STOPPED; }
  void reset() override {
    state_ = mcu_msgs__msg__ArmSusbsytem__PRE_INIT;
    position_state_ = mcu_msgs__msg__ArmSusbsytem__POSITION_RETRACTED;
    intake_state_ = mcu_msgs__msg__ArmSusbsytem__INTAKE_OFF;
    item_state_ = mcu_msgs__msg__ArmSusbsytem__ITEM_NONE;
    movement_start_time_ = 0;
  }
  const char* getInfo() override { return "ArmSubsystem"; }

  // micro-ROS wiring
  bool onCreate(rcl_node_t* node, rclc_executor_t* executor) override {
    node_ = node;
    // Pseudo-code: create publisher for `mcu_msgs/ArmSusbsytem`
    // rclc_publisher_init_default(&pub_state_, node_,
    //     ROSIDL_GET_MSG_TYPE_SUPPORT(mcu_msgs, msg, ArmSusbsytem),
    //     "arm/state");

    // Pseudo-code: create service for `mcu_msgs/srv/ArmControl`
    // rclc_service_init_default(&srv_control_, node_,
    //     ROSIDL_GET_SRV_TYPE_SUPPORT(mcu_msgs, srv, ArmControl),
    //     "arm/control");
    // rclc_executor_add_service(executor, &srv_control_, &srv_req_, &srv_res_,
    //     &ArmSubsystem::onServiceStatic, ON_NEW_REQUEST);

    return true;
  }
  void onDestroy() override {
    // Pseudo-code: clean up micro-ROS entities if needed
    // rcl_publisher_fini(&pub_state_, node_);
    // rcl_service_fini(&srv_control_, node_);
    node_ = nullptr;
  }

  // Pseudo-code: publish current arm status
  void publishState() {
    // Fill out `msg_` from internal state variables
    msg_.state = state_;
    msg_.position_state = position_state_;
    msg_.intake_state = intake_state_;
    msg_.item_state = item_state_;

    // Pseudo-code publish
    // rcl_publish(&pub_state_, &msg_, NULL);
  }

  // Service handler to control arm movement
  void handleServiceControl(const mcu_msgs__srv__ArmControl_Request* request,
                            mcu_msgs__srv__ArmControl_Response* response) {
    // Validate request - only accept commands when armed or running
    if (state_ != mcu_msgs__msg__ArmSusbsytem__ARMED &&
        state_ != mcu_msgs__msg__ArmSusbsytem__RUNNING) {
      response->accepted = false;
      // response->message =
      // rosidl_runtime_c__String__assign(&response->message, "Arm not ready");
      return;
    }

    // Set intake state
    intake_state_ = request->intake_command;
    // Pseudo-code: control intake motor/servo based on intake_state_
    // if (intake_state_ == mcu_msgs__msg__ArmSusbsytem__INTAKE_ON) {
    //   setup_.servo_->bufferPWM(INTAKE_CHANNEL, INTAKE_ON_PWM);
    // } else {
    //   setup_.servo_->bufferPWM(INTAKE_CHANNEL, INTAKE_OFF_PWM);
    // }

    // Handle position command
    target_position_state_ = request->target_position_state;

    if (target_position_state_ ==
        mcu_msgs__srv__ArmControl_Request__POSITION_CUSTOM) {
      target_custom_position_ = request->custom_position;
    }

    // Start movement sequence
    state_ = mcu_msgs__msg__ArmSusbsytem__RUNNING;
    position_state_ = mcu_msgs__msg__ArmSusbsytem__POSITION_MOVING;
    movement_start_time_ = millis();
    movement_speed_ = request->speed;

    // Pseudo-code: command servo to target position
    // int16_t target_pos = getTargetPosition(target_position_state_,
    // target_custom_position_); uint16_t pwm_value = positionToPWM(target_pos);
    // setup_.servo_->bufferPWM(ARM_JOINT_CHANNEL, pwm_value);

    response->accepted = true;
    // rosidl_runtime_c__String__assign(&response->message, "Command accepted");
  }

 private:
  // Non-blocking state transition handler
  void updateMovementState() {
    if (position_state_ == mcu_msgs__msg__ArmSusbsytem__POSITION_MOVING) {
      uint32_t elapsed = millis() - movement_start_time_;

      // Simple time-based movement completion (non-blocking delay)
      if (elapsed >= setup_.movement_duration_ms_) {
        // Movement complete, update to target state
        position_state_ = target_position_state_;

        // Pseudo-code: optionally verify position with encoder feedback
        // long actual_pos = setup_.encoder_->getPosition().position;
        // int16_t expected = getTargetPosition(target_position_state_,
        // target_custom_position_); if (abs(actual_pos - expected) <
        // POSITION_TOLERANCE_TICKS) {
        //   position_state_ = target_position_state_;
        // } else {
        //   // Handle error - position not reached, maybe retry or fault
        //   state_ = mcu_msgs__msg__ArmSusbsytem__INIT_FAIL;
        // }

        // Pseudo-code: check for item detection when intake is on
        // if (intake_state_ == mcu_msgs__msg__ArmSusbsytem__INTAKE_ON) {
        //   bool item_detected = digitalRead(ITEM_SENSOR_PIN);
        //   item_state_ = item_detected ?
        //       mcu_msgs__msg__ArmSusbsytem__ITEM_DETECTED :
        //       mcu_msgs__msg__ArmSusbsytem__ITEM_NONE;
        // }
      }
    }
  }

  // Pseudo-code helper: map target state to position value
  // int16_t getTargetPosition(uint8_t target_state, int16_t custom_pos) {
  //   switch (target_state) {
  //     case mcu_msgs__srv__ArmControl_Request__POSITION_RETRACTED:
  //       return ARM_RETRACTED_POS;  // e.g., 0 degrees
  //     case mcu_msgs__srv__ArmControl_Request__POSITION_EXTENDED:
  //       return ARM_EXTENDED_POS;   // e.g., 90 degrees
  //     case mcu_msgs__srv__ArmControl_Request__POSITION_CUSTOM:
  //       return custom_pos;
  //     default:
  //       return 0;
  //   }
  // }

  // Pseudo-code helper: convert position to PWM value
  // uint16_t positionToPWM(int16_t degrees) {
  //   // Map degrees to 12-bit PWM (0-4095)
  //   // Typical servo: 1ms (205) = 0°, 2ms (410) = 180°
  //   return map(degrees, 0, 180, 205, 410);
  // }

  // Static trampoline for service callback
  // static void onServiceStatic(const void* reqin, void* resin) {
  //   // Context would be passed via executor add_service
  //   auto* self = /* extract from context */;
  //   const auto* req = static_cast<const
  //   mcu_msgs__srv__ArmControl_Request*>(reqin); auto* res =
  //   static_cast<mcu_msgs__srv__ArmControl_Response*>(resin);
  //   self->handleServiceControl(req, res);
  // }

  const ArmSubsystemSetup setup_;

  // micro-ROS entities
  rcl_node_t* node_ = nullptr;
  rcl_publisher_t pub_state_{};
  rcl_service_t srv_control_{};

  // Messages (storage reused by executor)
  mcu_msgs__msg__ArmSusbsytem msg_{};
  mcu_msgs__srv__ArmControl_Request srv_req_{};
  mcu_msgs__srv__ArmControl_Response srv_res_{};

  // Internal arm states (mirror of `ArmSusbsytem.msg` constants)
  uint8_t state_ = mcu_msgs__msg__ArmSusbsytem__PRE_INIT;
  uint8_t position_state_ = mcu_msgs__msg__ArmSusbsytem__POSITION_RETRACTED;
  uint8_t intake_state_ = mcu_msgs__msg__ArmSusbsytem__INTAKE_OFF;
  uint8_t item_state_ = mcu_msgs__msg__ArmSusbsytem__ITEM_NONE;

  // Movement tracking for non-blocking delays
  uint8_t target_position_state_ =
      mcu_msgs__msg__ArmSusbsytem__POSITION_RETRACTED;
  int16_t target_custom_position_ = 0;
  uint8_t movement_speed_ = 128;
  uint32_t movement_start_time_ = 0;
};

}  // namespace Subsystem

#endif
